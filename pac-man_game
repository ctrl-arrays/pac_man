import tkinter as tk
import random
# Game Configuration
WINDOW_WIDTH = 600
WINDOW_HEIGHT = 600
PACMAN_SIZE = 30
PELLET_SIZE = 10
MOVE_DISTANCE = 20
GHOST_SIZE = 30
NUM_GHOSTS = 2

class PacManGame:
    def __init__(self, root):
        self.root = root
        self.root.title("Pac Man")

        self.canvas = tk.Canvas(root, width=WINDOW_WIDTH, height=WINDOW_HEIGHT, bg="black")
        self.canvas.pack()
        # Score and Lives
        self.score = 0
        self.lives = 3
        self.score_label = tk.Label(root, text="Score: 0", font=("Arial", 16), bg="black", fg="white")
        self.score_label.place(x=10, y=10)
        self.lives_label = tk.Label(root, text="Lives: 3", font=("Arial", 16), bg="black", fg="white")
        self.lives_label.place(x=120, y=10)
        # Pac Man and direction
        self.start_x = WINDOW_WIDTH // 2
        self.start_y = WINDOW_HEIGHT // 2
        self.pacman = self.canvas.create_oval(
            self.start_x, self.start_y,
            self.start_x + PACMAN_SIZE, self.start_y + PACMAN_SIZE,
            fill="yellow"
        )
        self.direction = None
        # Elements
        self.pellets = []
        self.ghosts = []
        self.walls = []

        self.create_walls()
        self.create_pellets()
        self.create_ghosts()

        self.canvas.bind_all("<KeyPress>", self.change_direction)

        self.game_running = True
        self.game_loop()

    def create_walls(self):
        """Create wall rectangles and store then"""
        wall_coords = [
            # Outer boundaries
            (0, 0, WINDOW_WIDTH, 20),  # Top
            (0, 0, 20, WINDOW_HEIGHT),  # Left
            (WINDOW_WIDTH - 20, 0, WINDOW_WIDTH, WINDOW_HEIGHT),  # Right
            (0, WINDOW_HEIGHT - 20, WINDOW_WIDTH, WINDOW_HEIGHT),  # Bottom

            # Inner maze walls        
            (100, 240, 120, 300),  # Vertical left(bottom segment) 
            (150, 100, 300, 120),  # Horizontal top
            (300, 120, 320, 300),  # Vertical middle
            (260, 280, 300, 300),  # Horizontal bottom (right half)
            (400, 100, 420, 400),  # Vertical right
            (420, 400, 580, 420),  # Horizontal bottom right
        ]
        for x1, y1, x2, y2 in wall_coords:
            wall = self.canvas.create_rectangle(x1, y1, x2, y2, fill="blue", outline="white")
            self.walls.append(wall)

    def create_pellets(self):
        for x in range(PELLET_SIZE * 4, WINDOW_WIDTH, 60):
            for y in range(PELLET_SIZE * 4, WINDOW_HEIGHT, 60):
                # Avoid placing pellets on walls
                overlap = False
                temp = self.canvas.create_oval(x, y, x + PELLET_SIZE, y + PELLET_SIZE)
                temp_coords = self.canvas.bbox(temp)
                for wall in self.walls:
                    if self.overlap(temp_coords, self.canvas.bbox(wall)):
                        overlap = True
                        break
                self.canvas.delete(temp)
                if not overlap:
                    pellet = self.canvas.create_oval(
                        x, y, x + PELLET_SIZE, y + PELLET_SIZE, fill="white", outline=""
                    ) 
                    self.pellets.append(pellet)

    def create_ghosts(self):
        for _ in range(NUM_GHOSTS):
            while True:
                x = random.randint(100, WINDOW_WIDTH - 100)
                y = random.randint(100, WINDOW_HEIGHT - 100)
                ghost = self.canvas.create_oval(x, y, x + GHOST_SIZE, y + GHOST_SIZE, fill="red")
                ghost_coords = self.canvas.bbox(ghost)
                
                overlap = False
                for wall in self.walls:
                    if self.overlap(ghost_coords, self.canvas.bbox(wall)):
                        overlap = True
                        break
                if not overlap:
                    for existing_ghost in self.ghosts:
                        if self.overlap(ghost_coords, self.canvas.bbox(existing_ghost)):
                            overlap = True
                            break
                if not overlap:
                    self.ghosts.append(ghost)
                    break
                else:
                    self.canvas.delete(ghost)

    def change_direction(self, event):
        if event.keysym in ("Up", "Down", "Left", "Right"):
            self.direction = event.keysym

    def move_pacman(self):
        if self.direction is None or not self.game_running:
            return
    
        dx, dy = 0, 0
        if self.direction == "Up":
            dy = -MOVE_DISTANCE
        elif self.direction == "Down":
            dy = MOVE_DISTANCE
        elif self.direction == "Left":
            dx = -MOVE_DISTANCE
        elif self.direction == "Right":
            dx = MOVE_DISTANCE

        # Predict next position
        x1, y1, x2, y2 = self.canvas.coords(self.pacman)
        new_coords = (x1 + dx, y1 + dy, x2 + dx, y2 + dy)
        # Check for wall collisions
        for wall in self.walls:
            if self.overlap(new_coords, self.canvas.bbox(wall)):
                return
        # Move if no collision
        if 0 <= new_coords[0] <= WINDOW_WIDTH - PACMAN_SIZE and 0 <= new_coords[1] <= WINDOW_HEIGHT - PACMAN_SIZE:
            self.canvas.move(self.pacman, dx, dy)

    def move_ghosts(self):
        for ghost in self.ghosts:
            dx = random.choice([-MOVE_DISTANCE, 0, MOVE_DISTANCE])
            dy = random.choice([-MOVE_DISTANCE, 0, MOVE_DISTANCE])

            gx1, gy1, gx2, gy2 = self.canvas.coords(ghost)
            new_coords = (gx1 + dx, gy1 + dy, gx2 + dx, gy2 + dy)
            # Stay in bounds
            if new_coords[0] < 0 or new_coords[2] > WINDOW_WIDTH or new_coords[1] < 0 or new_coords[3] > WINDOW_HEIGHT:
                continue
            # Check wall collision
            blocked = False
            for wall in self.walls:
                if self.overlap(new_coords, self.canvas.bbox(wall)):
                    blocked = True
                    break

            if not blocked:
                self.canvas.move (ghost, dx, dy)

    def check_pellet_collision(self):
        pac_coords = self.canvas.bbox(self.pacman)
        for ghost in self.ghosts:
            if self.overlap(pac_coords, self.canvas.bbox(ghost)):
                self.lose_life()
                return
                
        for pellet in self.pellets[:]:
            if self.overlap(pac_coords, self.canvas.bbox(pellet)):
                self.canvas.delete(pellet)
                self.pellets.remove(pellet)
                self.score += 10
                self.update_ui()
        # Win condition
        if not self.pellets and self.lives > 0:
            self.win_game()

    def lose_life(self):
        self.lives -= 1
        self.update_ui()
        if self.lives <= 0:
            self.end_game()
        else:
            self.canvas.coords(self.pacman, self.start_x, self.start_y, self.start_x + PACMAN_SIZE, self.start_y + PACMAN_SIZE)

    def update_ui(self):
        self.score_label.config(text=f"Score: {self.score}")
        self.lives_label.config(text=f"Lives: {self.lives}")

    def end_game(self):
        self.game_running = False
        self.canvas.create_text(
            WINDOW_WIDTH / 2, WINDOW_HEIGHT / 2,
            text="GAME OVER", fill="white",
            font=("Arial", 32, "bold")
        )

    def win_game(self):
        self.game_running = False
        self.canvas.create_text(
            WINDOW_WIDTH / 2, WINDOW_HEIGHT / 2,
            text="YOU WIN!", fill="white",
            font=("Arial", 32, "bold")
        )


    def overlap(self, box1, box2):
        x1, y1, x2, y2 = box1
        a1, b1, a2, b2 = box2
        return not (x2 < a1 or x1 > a2 or y2 < b1 or y1 > b2)

    def game_loop(self):
        if self.game_running:
            self.move_pacman()
            self.move_ghosts()
            self.check_pellet_collision()
        self.root.after(200, self.game_loop)
#Run the game
if __name__ == "__main__":
    root = tk.Tk()
    game = PacManGame(root)
    root.mainloop() 
